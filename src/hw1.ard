\import Data.Unit
\import Equiv
\import HLevel
\import Paths

\func unitIsProp : isProp Unit
    => \lam x y => \case x \with {| unit => \case y \with {| unit => idp}}

\func isContr (A : \Type) => \Sigma (a0 : A) (\Pi (a : A) -> a = a0)

\func toUnit {A : \Type} (f : A -> Unit) (a : A) : f a = unit
    => unitIsProp (f a) unit

\func isContr=>A~1 {A : \Type} (proof : isContr(A)) : (QEquiv {A} {Unit}) \cowith
    | f _ => unit
    | ret _ => proof.1
    | ret_f x => inv (proof.2 x)
    | f_sec y => unitIsProp y unit

\func A~1=>isProp {A : \Type} (e : QEquiv {A} {Unit}) : \Sigma (isProp A) A
    => (\lam x y =>
        inv (inv (pmap e.ret (toUnit e.f x)) *> e.ret_f x)
            *>
        (inv (pmap e.ret (toUnit e.f y)) *> e.ret_f y), e.ret unit)

\func isProp=>isContr {A : \Type} (proof : \Sigma (isProp A) A) : isContr(A)
    => (proof.2 , \lam a => proof.1 a proof.2)



\func task3a {A B : \Type} (f : A -> B) (a a' : A) (p : a = a') : f a' = f a'
    => transport (\lam x => f x = f x) p (idp {B} {f a})
{- тип выражения f a' = f a', значит можно упростить до idp {B} {f a'} -}

\func task3b {A : \Type} (a a' : A) (p : a = a') : a' = a'
    => transport (\lam x => x = a') p p
{- тип выражения a' = a', значит можно упростить до idp {A} {a'} -}

\func task3c {A : \Type} (a a' : A) (p : a = a') : a = a'
    => transport (\lam x => a = x) p (idp {A} {a})
{- тип выражения a = a', значит можно упростить до p -}